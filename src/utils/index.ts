import * as fs from 'fs';
import { Game } from '../types';
import { ActionRowBuilder, ButtonBuilder, ButtonStyle, CategoryChannel, ChannelType, Client, EmbedBuilder, Guild, } from 'discord.js';
import logger from '../logger';
import Team, { IPlayer, ITeamData } from '../api/models/Team';

export const games: Game[] = JSON.parse(fs.readFileSync('games.json', 'utf-8')).games;

export function generateTeamId(): string {
    return Math.random().toString(36).substring(2, 7).toUpperCase();
}

export async function isUserInAnyTeam(userId: string): Promise<boolean | void> {
    try {
        const team = await Team.findOne({
            status: 'active',
            $or: [
                { leader: userId },
                { players: userId },
                { reserve: userId }
            ]
        });
        return !!team;
    } catch (error) {
        
        logger.error('Error checking if user is in any team:', error);
    }
}

export function getGameNameByValue(value: string): string {
    const game = games.find(g => g.value === value);
    return game ? game.name : value;
}

export function createTeamEmbed(team: ITeamData): EmbedBuilder {
    const embed = new EmbedBuilder()
        .setTitle(`üéÆ –ö–æ–º–∞–Ω–¥–∞ ${team.teamId}`)
        .setColor('#00ff00');

    embed.addFields(
        { name: '–ì—Ä–∞', value: getGameNameByValue(team.game), inline: true }
    );

    if (team.startTime) {
        embed.addFields({ name: '–ß–∞—Å –ø–æ—á–∞—Ç–∫—É', value: team.startTime, inline: true });
    }
    
    if (team.notes) {
        embed.addFields({ name: '–ù–æ—Ç–∞—Ç–∫–∏', value: team.notes, inline: false });
    }

    if (team.voiceChannelId) {
        embed.addFields({ name: '–ì–æ–ª–æ—Å–æ–≤–∏–π –∫–∞–Ω–∞–ª', value: `<#${team.voiceChannelId}>`, inline: true });
    }
    
    const playerList = [];
    for (let i = 0; i < team.slots; i++) {
        if (i < team.players.length) {
            const player = team.players[i];
            const emoji = player.id === team.leader ? 'üëë' : (player.isAdmin ? 'üõ°Ô∏è' : 'üë§');
            playerList.push(`${emoji} <@${player.id}>`);
        } else {
            playerList.push('üîì –í—ñ–ª—å–Ω–µ –º—ñ—Å—Ü–µ');
        }
    }

    embed.addFields({ name: 'üë• –ì—Ä–∞–≤—Ü—ñ:', value: playerList.join('\n'), inline: false });

    if (team.reserve.length > 0) {
        const reserveList = team.reserve.map((player: IPlayer) => `üîπ <@${player.id}>`);
        embed.addFields({ name: 'üîÑ –ß–µ—Ä–≥–∞:', value: reserveList.join('\n'), inline: false });
    }
    embed.addFields({ name: 'üïí –°—Ç–≤–æ—Ä–µ–Ω–æ:', value: team.createdAt.toLocaleString(), inline: false });

    if (team.players.length === team.slots) {
        embed.addFields({ name: '‚úÖ –°—Ç–∞—Ç—É—Å:', value: '–ö–æ–º–∞–Ω–¥–∞ –ø–æ–≤–Ω–∞! üéâ', inline: false });
    }

    embed.setFooter({ text: `üÜì –í—ñ–ª—å–Ω–∏—Ö –º—ñ—Å—Ü—å: ${team.slots - team.players.length} | ‚è≥ –ú—ñ—Å—Ü—å —É —Ä–µ–∑–µ—Ä–≤—ñ: ${2 - team.reserve.length}` });

    return embed;
}

export function createTeamButtons(team: ITeamData): ActionRowBuilder<ButtonBuilder> {
    const isTeamFull = team.players.length >= team.slots;
    const isReserveFull = team.reserve.length >= 2;

    return new ActionRowBuilder<ButtonBuilder>()
        .addComponents(
            new ButtonBuilder()
                .setCustomId(`join_${team.teamId}`)
                .setLabel(isTeamFull ? (isReserveFull ? '–ü–æ–≤–Ω–∞' : '–í —á–µ—Ä–≥—É') : '–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è')
                .setStyle(isTeamFull ? (isReserveFull ? ButtonStyle.Secondary : ButtonStyle.Primary) : ButtonStyle.Success)
                .setDisabled(isTeamFull && isReserveFull),
            new ButtonBuilder()
                .setCustomId(`leave_${team.teamId}`)
                .setLabel('–ü–æ–∫–∏–Ω—É—Ç–∏')
                .setStyle(ButtonStyle.Danger),
            new ButtonBuilder()
                .setCustomId(`disband_${team.teamId}`)
                .setLabel('–†–æ–∑–ø—É—Å—Ç–∏—Ç–∏')
                .setStyle(ButtonStyle.Secondary)
        );
}

export async function updateTeamMessage(client: Client, teamId: string) {
    const team = await Team.findOne({ teamId: teamId });
    if (!team) {
        logger.error(`Team ${teamId} not found in database`);
        return;
    }
    const channel = await client.channels.fetch(team.channelId);
    if (channel?.isTextBased()) {
        const message = await channel.messages.fetch(team.messageId || '');
        const embed = createTeamEmbed(team);
        const row = createTeamButtons(team);
        await message.edit({ embeds: [embed], components: [row] });
    }
}

export async function getTeamIdByLeader(userId: string): Promise<string | null> {
    try {
        const team = await Team.findOne({ leader: userId, status: 'active' });
        return team ? team.teamId : null;
    } catch (error) {
        logger.error(`Error in getTeamIdByLeader: ${error}`);
        throw error;
    }
}


export async function findOrCreateGamesCategory(guild: Guild): Promise<CategoryChannel | null> {
    try {
        const existingCategory = guild.channels.cache.find(
            channel => channel.type === ChannelType.GuildCategory && channel.name.toUpperCase() === `TEMP VOICE CHANNELS (TEAM MASTER BOT)`
        ) as CategoryChannel | undefined;

        if (existingCategory) {
            return existingCategory;
        }

        const newCategory = await guild.channels.create({
            name: 'TEMP VOICE CHANNELS (TEAM MASTER BOT)',
            type: ChannelType.GuildCategory

        });

        logger.info(`Created new GAMES category in guild ${guild.id}`);
        return newCategory;
    } catch (error) {
        logger.error(`Failed to find or create GAMES category: ${error}`);
        return null;
    }
}

export function isPositiveResponse(input: string): boolean {
    const positiveResponses = ['—Ç–∞–∫', 'yes', 'y', '–¥–∞', 'true', '1'];
    return positiveResponses.includes(input.toLowerCase().trim());
}